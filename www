from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Tuple

import pendulum
from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.sensors.python import PythonSensor
from airflow.providers.oracle.hooks.oracle import OracleHook

from source.telegram_notifier import TelegramNotifier

# =========================
# Config
# =========================
TZ = "Asia/Oral"
ORACLE_CONN_ID = "db_oracle_ipc__edw_ipc"

# Workflow -> Task (INSTANCE_NAME Ğ² RB_REP.OPB_SWIDGINST_LOG)
WF_TASKS: Dict[str, str] = {
    "wf_PROD_edw_to_operations_account": "s_m_PROD_account_edw_to_operations",
    "wf_PROD_edw_to_operations_deposit": "s_m_PROD_deposit_edw_to_operations",
    "wf_PROD_edw_to_operations_openway": "s_m_PROD_openway_edw_to_operations",
}

default_args = {
    "depends_on_past": False,
    "start_date": pendulum.datetime(2025, 12, 23, tz=TZ),
    "retries": 1,
    "retry_delay": timedelta(minutes=15),
    "owner": "Yestay",
}

# =========================
# Oracle helpers
# =========================
def _oracle_fetch(sql: str, params: Dict) -> List[Tuple]:
    hook = OracleHook(oracle_conn_id=ORACLE_CONN_ID, thick_mode=True)
    conn = hook.get_conn()
    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
            return cur.fetchall()
    finally:
        conn.close()


def _bounds_for_day(context) -> Tuple[datetime, datetime]:
    """
    ĞĞºĞ½Ğ¾ Ğ´Ğ½Ñ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° DAG: 00:00..00:00 ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ´Ğ½Ñ Ğ¿Ğ¾ TZ.
    """
    ld = context["logical_date"].in_timezone(TZ)
    day_start = ld.start_of("day").naive()
    next_day_start = ld.add(days=1).start_of("day").naive()
    return day_start, next_day_start


def fetch_status_rows(day_start: datetime, next_day_start: datetime) -> List[Tuple]:
    """
    1 ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ½Ğ° workflow:
    (wf, tsk, workflow_run_id, wf_start_time, wf_end_time, wf_run_err_code,
     task_start_time, task_end_time, task_last_err_code, affected_rows)
    """
    wf_names = list(WF_TASKS.keys())
    wf_bind = ", ".join([f":wf{i}" for i in range(len(wf_names))])
    params: Dict[str, object] = {f"wf{i}": wf for i, wf in enumerate(wf_names)}
    params.update({"day_start": day_start, "next_day_start": next_day_start})

    need_rows = "\n    UNION ALL\n".join(
        [f"SELECT '{wf}' AS wf, '{tsk}' AS tsk FROM dual" for wf, tsk in WF_TASKS.items()]
    )

    sql = f"""
WITH bounds AS (
    SELECT :day_start AS day_start, :next_day_start AS next_day_start FROM dual
),
need AS (
    {need_rows}
),
last_run AS (
    SELECT
        r.workflow_id,
        r.workflow_name,
        r.workflow_run_id,
        r.start_time AS wf_start_time,
        r.end_time   AS wf_end_time,
        r.run_err_code AS wf_run_err_code,
        ROW_NUMBER() OVER (PARTITION BY r.workflow_id ORDER BY r.start_time DESC) rn
    FROM RB_REP.OPB_WFLOW_RUN r
    CROSS JOIN bounds b
    WHERE r.workflow_name IN ({wf_bind})
      AND r.start_time >= b.day_start
      AND r.start_time <  b.next_day_start
),
joined AS (
    SELECT
        n.wf,
        n.tsk,
        lr.workflow_id,
        lr.workflow_run_id,
        lr.wf_start_time,
        lr.wf_end_time,
        lr.wf_run_err_code,
        lg.start_time AS task_start_time,
        lg.end_time   AS task_end_time,
        lg.last_err_code AS task_last_err_code,
        NVL(lg.affected_rows, 0) AS affected_rows
    FROM need n
    LEFT JOIN last_run lr
        ON lr.workflow_name = n.wf
       AND lr.rn = 1
    LEFT JOIN RB_REP.OPB_SWIDGINST_LOG lg
        ON lg.workflow_id = lr.workflow_id
       AND lg.workflow_run_id = lr.workflow_run_id
       AND lg.instance_name = n.tsk
)
SELECT
    wf, tsk,
    workflow_run_id,
    wf_start_time, wf_end_time, wf_run_err_code,
    task_start_time, task_end_time, task_last_err_code,
    affected_rows
FROM joined
ORDER BY wf
"""
    return _oracle_fetch(sql, params)


def _wf_status(wf_run_id, wf_start, wf_end, wf_err) -> str:
    if wf_run_id is None:
        return "NO RUN"
    if wf_start is not None and wf_end is None:
        return "RUNNING"
    if wf_end is not None and (wf_err is not None) and int(wf_err) != 0:
        return "ERROR/WARNING"
    if wf_end is not None:
        return "SUCCESS"
    return "UNKNOWN"


def _task_status(wf_run_id, task_start, task_end, task_err, found_task: bool) -> str:
    if wf_run_id is None:
        return "NO RUN"
    if not found_task:
        return "TASK NOT FOUND"
    if task_start is not None and task_end is None:
        return "RUNNING"
    if task_end is not None and (task_err is not None) and int(task_err) != 0:
        return "ERROR/WARNING"
    if task_end is not None:
        return "SUCCESS"
    return "UNKNOWN"


def all_finished(**context) -> bool:
    day_start, next_day_start = _bounds_for_day(context)
    rows = fetch_status_rows(day_start, next_day_start)

    # Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾, ĞºĞ¾Ğ³Ğ´Ğ° Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ WF:
    # - ĞµÑÑ‚ÑŒ workflow_run_id
    # - wf_end_time not null
    # - task_end_time not null (task Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒÑÑ)
    for (
        wf,
        tsk,
        wf_run_id,
        wf_start,
        wf_end,
        wf_err,
        task_start,
        task_end,
        task_err,
        affected_rows,
    ) in rows:
        if wf_run_id is None:
            return False
        if wf_end is None:
            return False
        if task_end is None:
            return False

    return True


def build_message(rows: List[Tuple]) -> str:
    now_str = pendulum.now(TZ).to_datetime_string()
    lines = [f"ğŸ“Œ <b>EDW â†’ Operations</b> â€” Ğ¸Ñ‚Ğ¾Ğ³ (WF + TASK) ({now_str})", ""]

    for (
        wf,
        tsk,
        wf_run_id,
        wf_start,
        wf_end,
        wf_err,
        task_start,
        task_end,
        task_err,
        affected_rows,
    ) in rows:
        wf_st = _wf_status(wf_run_id, wf_start, wf_end, wf_err)
        task_found = task_start is not None or task_end is not None or task_err is not None
        task_st = _task_status(wf_run_id, task_start, task_end, task_err, task_found)

        ok = (wf_st == "SUCCESS") and (task_st == "SUCCESS")
        icon = "âœ…" if ok else "âš ï¸"

        lines.append(
            f"{icon} <b>{wf}</b>\n"
            f"WF_RUN_ID: <b>{wf_run_id}</b>\n"
            f"WF: <b>{wf_st}</b> | start: <b>{wf_start}</b> | end: <b>{wf_end}</b> | err: <b>{wf_err}</b>\n"
            f"TASK: <b>{tsk}</b> â€” <b>{task_st}</b> | start: <b>{task_start}</b> | end: <b>{task_end}</b> | err: <b>{task_err}</b>\n"
            f"AFFECTED_ROWS: <b>{affected_rows}</b>\n"
        )

    return "\n".join(lines)


def send_telegram(**context):
    bot_token = context["var"]["value"].get("telegram_bot_token")
    chat_id = context["var"]["value"].get("telegram_notifications_chat_id")
    proxies = {
        "http": context["var"]["value"].get("http_proxy"),
        "https": context["var"]["value"].get("https_proxy"),
    }

    notifier = TelegramNotifier(bot_token=bot_token, chat_id=chat_id)

    day_start, next_day_start = _bounds_for_day(context)
    rows = fetch_status_rows(day_start, next_day_start)

    notifier.send_message(build_message(rows), proxies)


with DAG(
    dag_id="prod_edw_to_operations_notify_after_all_done_every_tuesday",
    default_args=default_args,
    schedule="5 8 * * 2",  # ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¸Ğº Ğ² 08:05
    catchup=False,
    tags=["operations", "informatica", "telegram"],
) as dag:
    wait_all_done = PythonSensor(
        task_id="wait_all_workflows_and_tasks_done",
        python_callable=all_finished,
        mode="reschedule",
        poke_interval=10 * 60,   # ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚
        timeout=20 * 60 * 60,    # Ğ´Ğ¾ 20 Ñ‡Ğ°ÑĞ¾Ğ²
    )

    notify = PythonOperator(
        task_id="send_telegram_summary",
        python_callable=send_telegram,
    )

    wait_all_done >> notify