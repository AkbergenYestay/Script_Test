WITH /* Параметры периода (предыдущий календарный месяц + 5 дней по date_value, но без двойной фильтрации) */
params AS (
  SELECT
    /* начало предыдущего месяца по местной логике Oracle-совместимых функций */
    trunc(add_months(sysdate, -1), 'mm')        AS d_from,
    trunc(sysdate, 'mm')                         AS d_this_month,
    trunc(sysdate, 'mm') + 5                     AS d_val_to
  FROM dual
),

/* БАЗОВЫЕ ТРАНЗАКЦИИ (покупки) — один проход по таблице */
base_tx AS (
  SELECT /*+ parallel(4) */
         tr.iin_bin                                       AS iin,
         /* ключ операции для distinct */
         COALESCE(tr.ret_ref_number, tr.acq_ref_number)   AS tx_key,
         tr.ret_ref_number,
         tr.acq_ref_number,
         tr.local_sum,
         /* === КАТЕГОРИЯ ===
            РЕКОМЕНДАЦИЯ: заменить этот JOIN на справочник dim_sic_mcg с PK(sic_code).
            Если справочника нет — вставьте ваш большой CASE сюда вместо "mcg_name". */
         -- пример со справочником:
         COALESCE(mcg.mcg_name,
           /* fallback, если справочника нет — верните свой CASE сюда */
           'Разное'
         ) AS mcg_name
  FROM dds.w4_transaction_fl tr
  /* обязательная принадлежность к физлицам */
  JOIN dds.w4_gm_subject_s gms
       ON gms.dwh_id = tr.target_gm_subject_id
      AND gms.is_actual = 'A'
      AND gms.amnd_state = 'A'
      AND gms.fiz_fl = '1'
  JOIN dds.w4_client_type_h th
       ON gms.w4_client_type_id = th.dwh_id
  LEFT JOIN dds.w4_product_h a
       ON a.dwh_id = tr.w4_product_id
  LEFT JOIN dds.w4_sic_h sic
       ON sic.dwh_id = tr.w4_sic_id
  /* справочник категорий: dds.dim_sic_mcg(sic_code, mcg_name) */
  LEFT JOIN dds.dim_sic_mcg mcg
       ON mcg.sic_code = sic.sic_code
  CROSS JOIN params p
  WHERE
      /* дата расчётная: убираем TRUNC с колонки, сравниваем с константами */
      tr.date_value >= p.d_from
  AND tr.date_value  < p.d_val_to
      /* вторую проверку по trans_date оставляем одной парой границ без TRUNC на колонке */
  AND tr.trans_date >= p.d_from
  AND tr.trans_date <  p.d_this_month
      /* типы транзакций - покупки */
  AND tr.w4_trans_type_id IN (9322, 9350, 10030)
  AND tr.target_is_on_us = 'Y'
  AND tr.service_class = 'T'
  AND tr.request_category IN ('P')
  AND tr.direction = -1
  AND tr.iin_bin IS NOT NULL
  AND th.ccat = 'P'
  AND tr.device_type <> 'HOMEBANK'
  AND (a.product_name IS NULL OR (LOWER(a.product_name) NOT LIKE '%bus%' AND LOWER(a.product_name) NOT LIKE '%corp%'))
  /* отсечём денежные и пр. категории сразу */
  AND COALESCE(mcg.mcg_name,
       'Разное' /* если нет справочника/категории */) NOT IN ('Снятие наличных','Финансовые услуги','Переводы')
),

/* КОРРЕКТИРОВКИ ПО RET_REF_NUMBER: QR (9328, dir=1, on_us/on_us) и TOKEN (R,J по покупкам) */
adj_ret AS (
  SELECT /*+ parallel(4) */
         tr.iin_bin                 AS iin,
         tr.ret_ref_number,
         /* знак суммы: QR приход (direction=1) должен уменьшать расход ⇒ *-1 */
         SUM( CASE
                WHEN tr.w4_trans_type_id = 9328
                     AND tr.direction = 1
                     AND tr.target_is_on_us = 'Y'
                     AND tr.source_is_on_us = 'Y'
                  THEN -1 * tr.local_sum
                WHEN tr.w4_trans_type_id IN (9322,9350,10030)
                     AND tr.direction = -1
                     AND tr.target_is_on_us = 'Y'
                     AND tr.source_is_on_us = 'Y'
                     AND tr.request_category IN ('R','J')
                  THEN tr.local_sum
              END ) AS amt
  FROM dds.w4_transaction_fl tr
  CROSS JOIN params p
  WHERE
      tr.ret_ref_number IS NOT NULL
  AND  tr.date_value >= p.d_from
  AND  tr.date_value  < p.d_val_to
  AND  tr.trans_date >= p.d_from
  AND  tr.trans_date <  p.d_this_month
  AND  tr.w4_trans_type_id IN (9328, 9322, 9350, 10030)
  AND  tr.service_class = 'T'
  GROUP BY tr.iin_bin, tr.ret_ref_number
),

/* КОРРЕКТИРОВКИ ПО ACQ_REF_NUMBER: BVU (9328, source_is_on_us='N') и TOKEN_BVU (R,J по покупкам) */
adj_acq AS (
  SELECT /*+ parallel(4) */
         tr.iin_bin               AS iin,
         tr.acq_ref_number,
         SUM( CASE
                WHEN tr.w4_trans_type_id = 9328
                     AND tr.direction = 1
                     AND tr.target_is_on_us = 'Y'
                     AND tr.source_is_on_us = 'N'
                  THEN -1 * tr.local_sum
                WHEN tr.w4_trans_type_id IN (9322,9350,10030)
                     AND tr.direction = -1
                     AND tr.target_is_on_us = 'Y'
                     AND tr.source_is_on_us = 'N'
                     AND tr.request_category IN ('R','J')
                  THEN tr.local_sum
              END ) AS amt
  FROM dds.w4_transaction_fl tr
  CROSS JOIN params p
  WHERE
      tr.acq_ref_number IS NOT NULL
  AND  tr.date_value >= p.d_from
  AND  tr.date_value  < p.d_val_to
  AND  tr.trans_date >= p.d_from
  AND  tr.trans_date <  p.d_this_month
  AND  tr.w4_trans_type_id IN (9328, 9322, 9350, 10030)
  AND  tr.service_class = 'T'
  GROUP BY tr.iin_bin, tr.acq_ref_number
),

/* СВОД ПО КАТЕГОРИЯМ: складываем базовую сумму + корректировки по ссылкам */
mcg_agg AS (
  SELECT
      b.iin,
      b.mcg_name,
      SUM( b.local_sum
         + COALESCE(ar.amt,0)
         + COALESCE(aa.amt,0) )                     AS curr_amt_sum,
      /* считаем distinct только по реальным base-покупкам */
      COUNT(DISTINCT b.tx_key)                      AS curr_tr_cnt
  FROM base_tx b
  LEFT JOIN adj_ret ar
         ON ar.iin = b.iin AND ar.ret_ref_number = b.ret_ref_number
  LEFT JOIN adj_acq aa
         ON aa.iin = b.iin AND aa.acq_ref_number = b.acq_ref_number
  GROUP BY b.iin, b.mcg_name
),

/* РАНЖИРОВАНИЕ И ФИЛЬТР */
category_data AS (
  SELECT
      iin,
      mcg_name,
      ROW_NUMBER() OVER (PARTITION BY iin ORDER BY curr_amt_sum DESC) AS rank_num,
      curr_amt_sum AS amount,
      curr_tr_cnt AS transaction_cnt
  FROM mcg_agg
  WHERE curr_tr_cnt > 0
    AND curr_amt_sum >= 10
),

mcg_cnt AS (
  SELECT iin, MAX(rank_num) AS max_r
  FROM category_data
  GROUP BY iin
  HAVING MAX(rank_num) > 2
)

SELECT /*+ parallel(4) */
       cd.iin,
       -- период как в вашем варианте
       tstzrange(
         date_trunc('day', now())::timestamp - interval '5 hours',
         date_trunc('day', now() + interval '13 day')::timestamp + interval '19 hours',
         '[)'
       )                                                AS period,
       /* маппинг к product_code — без изменений */
       CASE cd.mcg_name
         WHEN 'Благотворительность'            THEN 'top3mcg_m_charity'
         WHEN 'Госуслуги'                      THEN 'top3mcg_m_govtech'
         WHEN 'Домашние животные'              THEN 'top3mcg_m_pet'
         WHEN 'Здоровье и уход'                THEN 'top3mcg_m_health'
         WHEN 'Кафе и рестораны'               THEN 'top3mcg_m_rest'
         WHEN 'Коммунальные услуги и связь'    THEN 'top3mcg_m_utility'
         WHEN 'Мебель'                         THEN 'top3mcg_m_furnit'
         WHEN 'Образование'                    THEN 'top3mcg_m_educ'
         WHEN 'Одежда, обувь, аксессуары'      THEN 'top3mcg_m_fashion'
         WHEN 'Переводы'                        THEN 'top3mcg_m_transf'
         WHEN 'Подарки'                         THEN 'top3mcg_m_gifts'
         WHEN 'Путешествия'                     THEN 'top3mcg_m_travel'
         WHEN 'Развлечение'                     THEN 'top3mcg_m_entert'
         WHEN 'Разное'                          THEN 'top3mcg_m_other'
         WHEN 'Ремонт'                          THEN 'top3mcg_m_constr'
         WHEN 'Спорт'                           THEN 'top3mcg_m_sport'
         WHEN 'Страхование'                     THEN 'top3mcg_m_insur'
         WHEN 'Супермаркеты и продукты'         THEN 'top3mcg_m_market'
         WHEN 'Техника и электроника'           THEN 'top3mcg_m_electr'
         WHEN 'Транспорт'                       THEN 'top3mcg_m_transport'
         WHEN 'Финансовые услуги'               THEN 'top3mcg_m_fin'
       END                                             AS product_code,
       CASE cd.rank_num WHEN 1 THEN 10 WHEN 2 THEN 20 WHEN 3 THEN 30 END AS priority,
       trunc(sysdate, 'mm') - 1                         AS snapshot_date,
       'month'                                          AS period_type,
       cd.amount,
       cd.transaction_cnt,
       trunc(sysdate)                                   AS upload_date
FROM category_data cd
JOIN mcg_cnt mc ON mc.iin = cd.iin
WHERE cd.rank_num <= 3;