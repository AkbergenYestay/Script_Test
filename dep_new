/*+
  QB_NAME(main)
  LEADING(b ff ctr ac g ol r dot sot pot)
  USE_NL(ff ctr ac g ol r dot sot pot)
  INDEX(ff RS_GL_HALFENTRY_FL_X1)          -- локальный по (date_value, entry_id)
  INDEX(pd RS_PD_PAYMENT_FL_X1)            -- локальный по (date_value, entry_id)
  INDEX(cash RS_PD_ORDCASH_FL_X1)          -- локальный по (date_value, entry_id)
  INDEX(o RS_DS_HALFENTRY_OPER_L_X1)       -- локальный по (date_value, entry_id, actual_from DESC)
  INDEX(ca RS_DS_CONTRACT_ACCOUNT_L_IDX1)  -- по (gl_account_h_id) или составной, см. ниже
  INDEX(ch RS_DS_CONTRACT_H_PK)
  NO_MERGE(ctr)
  NO_EXPAND
*/
WITH
params AS (
  SELECT TO_DATE(:p_date,'dd.mm.yyyy') d FROM dual
),
-- Узкий драйвер: половинки проводок за день
ff AS (
  SELECT /*+ QB_NAME(ffv) */
         ff.entry_id, ff.source_id AS trn_id, ff.gm_currency_id AS ddepo_currency,
         ff.exec_date AS ddepo_fromdate, ff.sdok_sum AS oper_sum,
         ff.sdok_sum_nat AS oper_sum_nat, ff.gl_account_h_id, ff.gm_subject_h_id
  FROM dds.RS_GL_HALFENTRY_FL ff
  JOIN params p ON ff.date_value = p.d
),
-- Активные контрактные счета -> отфильтровываем сразу
ctr AS (
  SELECT /*+ QB_NAME(ctrv) */
         ca.gl_account_h_id
  FROM dds.RS_DS_CONTRACT_ACCOUNT_L ca
  JOIN dds.RS_DS_CONTRACT_H ch
    ON ch.id = ca.rs_ds_contract_h_id
   AND ch.is_actual = 'A'
   AND ca.is_actual = 'A'
  GROUP BY ca.gl_account_h_id
),
-- Последняя операция на дату
oper AS (
  SELECT /*+ QB_NAME(operv) */ o.entry_id, o.doc, o.dscr,
         o.rs_gm_opertype_id_dot AS dot_id,
         o.rs_gm_opertype_id_sot AS sot_id,
         o.rs_gm_opertype_id_pot AS pot_id,
         ROW_NUMBER() OVER (PARTITION BY o.entry_id
                            ORDER BY o.actual_from DESC NULLS LAST) rn
  FROM dds.RS_DS_HALFENTRY_OPER_L o
  JOIN params p ON o.date_value = p.d
),
oper_last AS (
  SELECT entry_id, doc, dscr, dot_id, sot_id, pot_id
  FROM oper
  WHERE rn = 1
),
-- refer из PD или CASH (приоритет PD)
ref_union AS (
  SELECT entry_id,
         MAX(refer) KEEP (DENSE_RANK FIRST ORDER BY pri) AS refer
  FROM (
    SELECT /*+ QB_NAME(pdq) */ pd.entry_id, pd.refer, 1 AS pri
    FROM dds.RS_PD_PAYMENT_FL pd
    JOIN params p ON pd.date_value = p.d
    UNION ALL
    SELECT /*+ QB_NAME(cashq) */ c.entry_id, c.refer, 2 AS pri
    FROM dds.RS_PD_ORDCASH_FL c
    JOIN params p ON c.date_value = p.d
  ) u
  GROUP BY entry_id
)
SELECT
  'COLVIR_DEPO' AS system,
  f.ddepo_currency,
  f.ddepo_fromdate,
  f.oper_sum,
  f.oper_sum_nat,
  r.refer,
  f.trn_id,
  CAST(ac.account_number AS VARCHAR2(50)) AS id,
  CASE WHEN ac.incom_fl = 1 THEN 0 ELSE 1 END AS dohod,
  COALESCE(ol.dscr, dot.longname, sot.longname, pot.longname, ol.doc) AS operation_name,
  g.iin_bin AS iin,
  g.longname AS name,
  dot.longname AS dot_longname,
  sot.longname AS sot_longname,
  pot.longname AS pot_longname
FROM ff f
/* Сжимаем поток РАНО: semi-join по активным контрактам */
WHERE EXISTS (
  SELECT 1 FROM ctr
  WHERE ctr.gl_account_h_id = f.gl_account_h_id
)
JOIN dds.gl_account_h ac ON ac.id = f.gl_account_h_id
JOIN dds.gm_subject_h g  ON g.id  = f.gm_subject_h_id
LEFT JOIN oper_last ol   ON ol.entry_id = f.entry_id
LEFT JOIN ref_union r    ON r.entry_id  = f.entry_id
LEFT JOIN dds.RS_GM_OPERTYPE_H dot ON dot.id = ol.dot_id AND dot.is_actual = 'A'
LEFT JOIN dds.RS_GM_OPERTYPE_H sot ON sot.id = ol.sot_id AND sot.is_actual = 'A'
LEFT JOIN dds.RS_GM_OPERTYPE_H pot ON pot.id = ol.pot_id AND pot.is_actual = 'A';