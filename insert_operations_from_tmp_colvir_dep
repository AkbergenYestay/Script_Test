-- DROP PROCEDURE cdo.insert_operations_from_tmp_colvir_dep(in date, in date, out int4, out int4, out text);

CREATE OR REPLACE PROCEDURE cdo.insert_operations_from_tmp_colvir_dep(
    IN  p_date_value_start date,
    IN  p_date_value_end   date,
    OUT p_rows_operations  integer,
    OUT p_rows_cv_account  integer,
    OUT p_error_message    text
)
LANGUAGE plpgsql
AS $procedure$
BEGIN
    p_rows_operations := 0;
    p_rows_cv_account := 0;
    p_error_message   := NULL;

    RAISE NOTICE
        'Запуск insert_operations_from_tmp_colvir_dep для p_date_value_start = % p_date_value_end = %',
        p_date_value_start, p_date_value_end;

    WITH src AS (
        -- Берём данные из tmp_colvir_dep и оставляем последний snapshot по логической операции
        SELECT *
        FROM (
            SELECT
                CASE WHEN tmp."system" = 'COLVIR_DEPO' THEN 4 END AS system_type,
                tmp.user_id::uuid                  AS user_id,
                tmp.currency,
                tmp.date1,
                tmp.amount_in_currency,
                tmp.amount_kzt,
                tmp.refer,
                tmp.trn_id,
                tmp.trn_doc_num,
                tmp.from1,
                tmp.income,
                tmp.operation_details,
                tmp.iin,
                tmp.nord,
                tmp.code_st,
                tmp.short_dscr,
                tmp.state,
                tmp.between_own_accounts,
                tmp.snapshot_date,
                tmp.date_value,
                tmp.category_id,
                subc.id                            AS sub_category_id,
                row_number() OVER (
                    PARTITION BY tmp.user_id, tmp.trn_id, tmp.nord, tmp.date_value
                    ORDER BY tmp.snapshot_date DESC
                ) AS rn
            FROM cdo.tmp_colvir_dep tmp
            LEFT JOIN public.sub_categories subc
                   ON tmp.category_id = subc.id
            WHERE tmp.date_value BETWEEN p_date_value_start AND p_date_value_end
        ) t
        WHERE t.rn = 1    -- только последняя версия операции
    ),

    -- Оставляем только те операции, которых ещё нет в cdo.operations
    src_for_operations AS (
        SELECT s.*
        FROM src s
        WHERE NOT EXISTS (
            SELECT 1
            FROM cdo.operations o
            WHERE o.user_id    = s.user_id
              AND o.oper_id    = s.trn_id
              AND o.nord       = s.nord
              AND o.date_value = s.date_value
        )
    ),

    -- Вставляем новые операции
    inserted_operations AS (
        INSERT INTO cdo.operations (
            user_id,
            "date",
            income,
            amount_in_currency,
            system_type,
            "from",
            "to",
            from_currency,
            to_currency,
            amount_kzt,
            state,
            fee,
            category_id,
            sub_category_id,
            process_id,
            short_desc,
            trans_type_name,
            oper_id,
            nord,
            date_value
        )
        SELECT
            s.user_id,
            s.date1 AS "date",
            CASE WHEN s.income = 1 THEN TRUE ELSE FALSE END AS income,
            s.amount_in_currency,
            s.system_type,
            s.from1,
            s.from1,
            (REPLACE(s.currency, ',', '.')::numeric)::smallint AS from_currency,
            (REPLACE(s.currency, ',', '.')::numeric)::smallint AS to_currency,
            s.amount_kzt,
            s.state,
            NULL AS fee,
            s.category_id,
            s.sub_category_id,
            NULL AS process_id,
            s.short_dscr,
            s.short_dscr                                    AS trans_type_name,
            s.trn_id                                        AS oper_id,
            s.nord,
            s.date_value
        FROM src_for_operations s
        RETURNING id
    ),

    -- Для всех операций (и новых, и существующих) находим их id
    src_with_operation_id AS (
        SELECT
            o.id               AS operation_id,
            s.operation_details,
            s.trn_id,
            s.refer,
            s.trn_doc_num,
            s.nord,
            s.between_own_accounts,
            s.code_st,
            s.date1            AS operation_date
        FROM src s
        JOIN cdo.operations o
          ON o.user_id    = s.user_id
         AND o.oper_id    = s.trn_id
         AND o.nord       = s.nord
         AND o.date_value = s.date_value
    ),

    -- Вставляем детали операций в colvir_dep_operations, без дублей по operation_id
    inserted_cv AS (
        INSERT INTO cdo.colvir_dep_operations (
            operation_id,
            operation_details,
            trn_id,
            refer,
            trn_doc_num,
            nord,
            between_own_accounts,
            code_st,
            operation_date
        )
        SELECT
            sw.operation_id,
            sw.operation_details,
            sw.trn_id,
            sw.refer,
            sw.trn_doc_num,
            sw.nord,
            sw.between_own_accounts,
            sw.code_st,
            sw.operation_date
        FROM src_with_operation_id sw
        ON CONFLICT (operation_id) DO NOTHING
        RETURNING operation_id
    )

    SELECT
        COALESCE((SELECT COUNT(*) FROM inserted_operations), 0),
        COALESCE((SELECT COUNT(*) FROM inserted_cv), 0)
    INTO p_rows_operations, p_rows_cv_account;

    RAISE NOTICE
        'Вставлено % записей в cdo.operations и % записей в cdo.colvir_dep_operations',
        p_rows_operations, p_rows_cv_account;

EXCEPTION
    WHEN OTHERS THEN
        p_rows_operations := 0;
        p_rows_cv_account := 0;
        p_error_message   := SQLERRM;

        RAISE NOTICE
            'Ошибка при выполнении insert_operations_from_tmp_colvir_dep: %',
            p_error_message;
END;
$procedure$;