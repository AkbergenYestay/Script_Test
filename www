from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional

import pendulum
from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.sensors.python import PythonSensor
from airflow.providers.oracle.hooks.oracle import OracleHook

from source.telegram_notifier import TelegramNotifier

# =========================
# Config
# =========================
TZ = "Asia/Oral"
ORACLE_CONN_ID = "db_oracle_ipc__edw_ipc"

# Workflow -> Informatica task (INSTANCE_NAME in RB_REP.OPB_SWIDGINST_LOG)
WF_TASKS: Dict[str, str] = {
    "wf_w4_pfm_top1mcg": "pfm_top1mcg1",
    "wf_w4_pfm_top3_transactions": "pfm_top3_transactions1",
    "wf_w4_pfm_top3_merchants": "pfm_top3_merchants1",
    "wf_w4_pfm_treat_yourself": "pfm_treat_yourself1",
}

default_args = {
    "depends_on_past": False,
    "start_date": pendulum.datetime(2025, 12, 23, tz=TZ),
    "retries": 1,
    "retry_delay": timedelta(minutes=15),
    "owner": "Yestay",
}


# =========================
# Oracle helpers
# =========================
def _oracle_fetch(sql: str, params: Dict) -> List[Tuple]:
    hook = OracleHook(oracle_conn_id=ORACLE_CONN_ID, thick_mode=True)
    conn = hook.get_conn()
    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
            return cur.fetchall()
    finally:
        conn.close()


def _bounds_for_tuesday_of_run(context) -> Tuple[datetime, datetime]:
    """
    Ğ”Ğ°Ñ‘Ğ¼ "Ğ¾ĞºĞ½Ğ¾" Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¸ĞºĞ° (00:00..00:00 ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ´Ğ½Ñ) Ğ´Ğ»Ñ Ğ´Ğ°Ñ‚Ñ‹ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ´Ğ°Ğ³Ğ°.
    Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ logical_date (Ğ´Ğ°Ñ‚Ğ° Ğ´Ğ°Ğ³-Ñ€Ğ°Ğ½Ğ°), Ğ° Ğ½Ğµ sysdate Ğ¸Ğ· Oracle.
    """
    ld = context["logical_date"].in_timezone(TZ)
    tue_start = ld.start_of("day").naive()
    wed_start = ld.add(days=1).start_of("day").naive()
    return tue_start, wed_start


def fetch_status_rows(tue_start: datetime, wed_start: datetime) -> List[Tuple]:
    """
    1 ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ½Ğ° workflow Ğ¸Ğ· WF_TASKS:
    (wf, tsk, workflow_run_id, wf_start_time, wf_end_time, wf_run_err_code,
     task_start_time, task_end_time, task_last_err_code, affected_rows)
    """
    # binds
    wf_names = list(WF_TASKS.keys())
    wf_bind = ", ".join([f":wf{i}" for i in range(len(wf_names))])
    params: Dict[str, object] = {f"wf{i}": wf for i, wf in enumerate(wf_names)}
    params.update({"tue_start": tue_start, "wed_start": wed_start})

    # need CTE
    need_rows = "\n    UNION ALL\n".join(
        [
            f"SELECT '{wf}' AS wf, '{tsk}' AS tsk FROM dual"
            for wf, tsk in WF_TASKS.items()
        ]
    )

    sql = f"""
WITH bounds AS (
    SELECT :tue_start AS tue_start, :wed_start AS wed_start FROM dual
),
need AS (
    {need_rows}
),
last_run AS (
    SELECT
        r.workflow_id,
        r.workflow_name,
        r.workflow_run_id,
        r.start_time AS wf_start_time,
        r.end_time   AS wf_end_time,
        r.run_err_code AS wf_run_err_code,
        ROW_NUMBER() OVER (PARTITION BY r.workflow_id ORDER BY r.start_time DESC) rn
    FROM RB_REP.OPB_WFLOW_RUN r
    CROSS JOIN bounds b
    WHERE r.workflow_name IN ({wf_bind})
      AND r.start_time >= b.tue_start
      AND r.start_time <  b.wed_start
),
joined AS (
    SELECT
        n.wf,
        n.tsk,
        lr.workflow_id,
        lr.workflow_run_id,
        lr.wf_start_time,
        lr.wf_end_time,
        lr.wf_run_err_code,
        lg.start_time AS task_start_time,
        lg.end_time   AS task_end_time,
        lg.last_err_code AS task_last_err_code,
        NVL(lg.affected_rows, 0) AS affected_rows
    FROM need n
    LEFT JOIN last_run lr
        ON lr.workflow_name = n.wf
       AND lr.rn = 1
    LEFT JOIN RB_REP.OPB_SWIDGINST_LOG lg
        ON lg.workflow_id = lr.workflow_id
       AND lg.workflow_run_id = lr.workflow_run_id
       AND lg.instance_name = n.tsk
)
SELECT
    wf, tsk,
    workflow_run_id,
    wf_start_time, wf_end_time, wf_run_err_code,
    task_start_time, task_end_time, task_last_err_code,
    affected_rows
FROM joined
ORDER BY wf
"""
    return _oracle_fetch(sql, params)


# =========================
# Status formatting
# =========================
def _wf_status(wf_run_id, wf_start, wf_end, wf_err) -> str:
    if wf_run_id is None:
        return "NO RUN"
    if wf_start is not None and wf_end is None:
        return "RUNNING"
    if wf_end is not None and (wf_err is not None) and int(wf_err) != 0:
        return "ERROR/WARNING"
    if wf_end is not None:
        return "SUCCESS"
    return "UNKNOWN"


def _task_status(wf_run_id, task_start, task_end, task_err, found_task: bool) -> str:
    if wf_run_id is None:
        return "NO RUN"
    if not found_task:
        return "TASK NOT FOUND"
    if task_start is not None and task_end is None:
        return "RUNNING"
    if task_end is not None and (task_err is not None) and int(task_err) != 0:
        return "ERROR/WARNING"
    if task_end is not None:
        return "SUCCESS"
    return "UNKNOWN"


# =========================
# Sensor / notifier
# =========================
def all_finished(**context) -> bool:
    tue_start, wed_start = _bounds_for_tuesday_of_run(context)
    rows = fetch_status_rows(tue_start, wed_start)

    # finished == ĞµÑÑ‚ÑŒ RUN_ID, WF_END_TIME, TASK_END_TIME (Ğ¾ÑˆĞ¸Ğ±ĞºĞ°/ÑƒÑĞ¿ĞµÑ… Ğ½Ğµ Ğ²Ğ°Ğ¶Ğ½Ğ¾ â€” ÑÑ‚Ğ¾ ÑƒĞ¶Ğµ Ñ„Ğ¸Ğ½Ğ°Ğ»)
    for (
        wf,
        tsk,
        wf_run_id,
        wf_start,
        wf_end,
        wf_err,
        task_start,
        task_end,
        task_err,
        affected_rows,
    ) in rows:
        if wf_run_id is None:
            return False
        if wf_end is None:
            return False
        # task Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¸ Ğ·Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½
        if task_end is None:
            return False

    return True


def build_message(rows: List[Tuple]) -> str:
    now_str = pendulum.now(TZ).to_datetime_string()
    lines = [f"ğŸ“Œ <b>PFM Informatica</b> â€” Ğ¸Ñ‚Ğ¾Ğ³ (WF + TASK) ({now_str})", ""]

    for (
        wf,
        tsk,
        wf_run_id,
        wf_start,
        wf_end,
        wf_err,
        task_start,
        task_end,
        task_err,
        affected_rows,
    ) in rows:
        wf_st = _wf_status(wf_run_id, wf_start, wf_end, wf_err)
        task_found = task_start is not None or task_end is not None or task_err is not None
        task_st = _task_status(wf_run_id, task_start, task_end, task_err, task_found)

        ok = (wf_st == "SUCCESS") and (task_st == "SUCCESS")
        icon = "âœ…" if ok else "âš ï¸"

        lines.append(
            f"{icon} <b>{wf}</b>\n"
            f"WF_RUN_ID: <b>{wf_run_id}</b>\n"
            f"WF: <b>{wf_st}</b> | start: <b>{wf_start}</b> | end: <b>{wf_end}</b> | err: <b>{wf_err}</b>\n"
            f"TASK: <b>{tsk}</b> â€” <b>{task_st}</b> | start: <b>{task_start}</b> | end: <b>{task_end}</b> | err: <b>{task_err}</b>\n"
            f"AFFECTED_ROWS: <b>{affected_rows}</b>\n"
        )

    return "\n".join(lines)


def send_telegram(**context):
    bot_token = context["var"]["value"].get("telegram_bot_token")
    chat_id = context["var"]["value"].get("telegram_notifications_chat_id")
    proxies = {
        "http": context["var"]["value"].get("http_proxy"),
        "https": context["var"]["value"].get("https_proxy"),
    }

    notifier = TelegramNotifier(bot_token=bot_token, chat_id=chat_id)

    tue_start, wed_start = _bounds_for_tuesday_of_run(context)
    rows = fetch_status_rows(tue_start, wed_start)

    message = build_message(rows)
    notifier.send_message(message, proxies)


with DAG(
    dag_id="pfm_notify_after_all_informatica_loads_done_every_tuesday",
    default_args=default_args,
    schedule="5 7 * * 2",  # ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ñ‚Ğ¾Ñ€Ğ½Ğ¸Ğº Ğ² 07:05 (Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°/Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ»Ğ°Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ÑÑ‚Ğ°Ñ€Ñ‚Ğ°)
    catchup=False,
    tags=["pfm", "informatica", "telegram"],
) as dag:
    wait_all_done = PythonSensor(
        task_id="wait_all_workflows_and_tasks_done",
        python_callable=all_finished,
        mode="reschedule",
        poke_interval=10 * 60,    # ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 10 Ğ¼Ğ¸Ğ½ÑƒÑ‚
        timeout=20 * 60 * 60,     # Ğ´Ğ¾ 20 Ñ‡Ğ°ÑĞ¾Ğ²
    )

    notify = PythonOperator(
        task_id="send_telegram_summary",
        python_callable=send_telegram,
    )

    wait_all_done >> notify