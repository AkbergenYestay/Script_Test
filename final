import datetime
import pandas as pd

from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.sensors.python import PythonSensor
from airflow.providers.oracle.hooks.oracle import OracleHook
from airflow.utils.email import send_email
from airflow.models import Variable

from source.telegram_topic_notifier import TelegramTopicNotifier
from source.telegram_notifications import TelegramErrorNotification


# =========================
# DAG DEFAULT ARGS
# =========================
default_args = {
    "owner": "Yestay",
    "email": ["EstayA@halykbank.kz"],
    "email_on_failure": True,
    "depends_on_past": False,
}

SENT_VAR = "top_pfm_email_sent"


# =========================
# SQL — MONITOR WORKFLOWS
# =========================
SQL_MONITOR_WF_TASK_BY_ID = """
WITH need AS (
    -- wf_w4_pfm_top1mcg -> s_m_w4_pfm_top1mcg
    SELECT 7387 AS workflow_id, 7389 AS task_id FROM dual UNION ALL

    -- wf_w4_pfm_top3_transactions -> s_m_w4_pfm_top3_transactions
    SELECT 7468, 7470 FROM dual UNION ALL

    -- wf_w4_pfm_top3_merchants -> s_m_w4_pfm_top3_merchants
    SELECT 7427, 7429 FROM dual UNION ALL

    -- wf_w4_pfm_treat_yourself -> s_m_w4_pfm_treat_yourself
    SELECT 7418, 7421 FROM dual
),
last_wf_run AS (
    SELECT
        r.workflow_id,
        r.workflow_name,
        r.workflow_run_id,
        r.start_time AS wf_start_time,
        r.end_time   AS wf_end_time,
        r.run_err_code,
        ROW_NUMBER() OVER (PARTITION BY r.workflow_id ORDER BY r.start_time DESC) rn
    FROM RB_REP.OPB_WFLOW_RUN r
    WHERE TRUNC(r.start_time) = TRUNC(SYSDATE)
      AND r.workflow_id IN (SELECT workflow_id FROM need)
),
ins_rows AS (
    SELECT
        s.workflow_run_id,
        MAX(s.affected_rows) AS inserted_rows
    FROM RB_REP.OPB_SWIDGINST_LOG s
    GROUP BY s.workflow_run_id
),
last_task_run AS (
    SELECT
        tr.workflow_run_id,
        tr.task_id,
        tr.start_time AS task_start_time,
        CASE
            WHEN tr.end_time IS NULL THEN NULL
            WHEN tr.end_time > SYSDATE THEN NULL
            WHEN tr.end_time < tr.start_time THEN NULL
            ELSE tr.end_time
        END AS task_end_time,
        tr.run_err_code AS task_run_err_code,
        ROW_NUMBER() OVER (
            PARTITION BY tr.workflow_run_id, tr.task_id
            ORDER BY tr.start_time DESC
        ) rn
    FROM RB_REP.OPB_TASK_INST_RUN tr
    WHERE TRUNC(tr.start_time) = TRUNC(SYSDATE)
      AND tr.task_id IN (SELECT task_id FROM need)
)
SELECT
    w.workflow_name,
    w.workflow_id,
    w.workflow_run_id,
    w.wf_start_time,
    w.wf_end_time,
    CASE
        WHEN w.workflow_run_id IS NULL THEN 'NOT STARTED'
        WHEN w.wf_end_time IS NULL THEN 'RUNNING'
        WHEN NVL(w.run_err_code,0) <> 0 THEN 'ERROR/WARNING'
        ELSE 'SUCCESS'
    END AS wf_status,
    NVL(ir.inserted_rows, 0) AS inserted_rows,
    tr.task_start_time,
    tr.task_end_time,
    CASE
        WHEN tr.task_start_time IS NULL THEN 'TASK NO RUN'
        WHEN tr.task_end_time IS NULL THEN 'TASK RUNNING'
        WHEN NVL(tr.task_run_err_code,0) <> 0 THEN 'TASK ERROR/WARNING'
        ELSE 'TASK SUCCESS'
    END AS task_status
FROM need n
LEFT JOIN last_wf_run w
    ON w.workflow_id = n.workflow_id AND w.rn = 1
LEFT JOIN ins_rows ir
    ON ir.workflow_run_id = w.workflow_run_id
LEFT JOIN last_task_run tr
    ON tr.workflow_run_id = w.workflow_run_id
   AND tr.task_id = n.task_id
   AND tr.rn = 1
ORDER BY n.workflow_id
"""


# =========================
# HELPERS
# =========================
def fmt_int(v) -> str:
    try:
        return f"{int(v):,}".replace(",", " ")
    except Exception:
        return "0"


def fetch_df() -> pd.DataFrame:
    hook = OracleHook(oracle_conn_id="db_oracle_ipc__edw_ipc", thick_mode=True)
    conn = hook.get_conn()
    try:
        with conn.cursor() as c:
            c.execute(SQL_MONITOR_WF_TASK_BY_ID)
            rows = c.fetchall()
            cols = [col[0] for col in c.description]
    finally:
        conn.close()
    return pd.DataFrame(rows, columns=cols)


# =========================
# SENSOR
# =========================
def wait_all_done(**_):
    today = datetime.date.today().isoformat()
    if Variable.get(SENT_VAR, "1970-01-01") == today:
        return True

    df = fetch_df()
    if df.empty:
        return False

    not_finished = df[
        df["WF_END_TIME"].isna() | df["TASK_END_TIME"].isna()
    ]
    return not not_finished.empty is False


# =========================
# NOTIFICATIONS
# =========================
def send_notifications(**context):
    today = datetime.date.today().isoformat()
    if Variable.get(SENT_VAR, "1970-01-01") == today:
        return

    df = fetch_df()
    if df.empty:
        return

    has_errors = (
        df["WF_STATUS"].isin(["ERROR/WARNING"]).any()
        or df["TASK_STATUS"].isin(["TASK ERROR/WARNING"]).any()
    )

    # ---------- EMAIL ----------
    subject = (
        "❌ Витрины PFM — ОШИБКА"
        if has_errors
        else "✅ Витрины PFM — успешно"
    )

    html = [f"<b>Дата:</b> {today}<br><br>"]
    for _, r in df.iterrows():
        html.append(
            f"<b>{r['WORKFLOW_NAME']}</b><br>"
            f"Старт: {r['WF_START_TIME']}<br>"
            f"Завершение: {r['WF_END_TIME']}<br>"
            f"Статус: {r['WF_STATUS']}<br>"
            f"Кол-во записей: {fmt_int(r['INSERTED_ROWS'])}<br><br>"
        )

    send_email(
        to=default_args["email"],
        subject=subject,
        html_content="".join(html),
    )

    # ---------- TELEGRAM (STATUS TOPIC) ----------
    bot = context["var"]["value"].get("telegram_bot_token")
    chat = context["var"]["value"].get("new_notifications_chat_id")
    topic = context["var"]["value"].get("topic_id_for_cvm_notifications")

    if bot and chat and topic:
        notifier = TelegramTopicNotifier(
            bot_token=bot,
            chat_id=chat,
            topic_id=int(topic),
        )

        header = (
            "❌ <b>Витрины PFM (вторник)</b>\n"
            if has_errors
            else "✅ <b>Витрины PFM (вторник)</b>\n"
        )

        parts = [header, f"Дата: {today}\n\n"]
        for _, r in df.iterrows():
            parts.append(
                f"• {r['WORKFLOW_NAME']}\n"
                f"  Старт: {r['WF_START_TIME']}\n"
                f"  Завершение: {r['WF_END_TIME']}\n"
                f"  Статус: {r['WF_STATUS']}\n"
                f"  Записей: {fmt_int(r['INSERTED_ROWS'])}\n\n"
            )

        notifier.send_message("".join(parts))

    Variable.set(SENT_VAR, today)


# =========================
# DAG
# =========================
with DAG(
    dag_id="pfm_start_every_tuesday",
    default_args=default_args,
    start_date=datetime.datetime(2025, 1, 1),
    schedule="0 9 * * *",
    catchup=False,
    max_active_runs=1,
    tags=["pfm"],
) as dag:

    wait = PythonSensor(
        task_id="wait_all_workflows_done",
        python_callable=wait_all_done,
        mode="reschedule",
        poke_interval=900,
        timeout=16 * 60 * 60,
        on_failure_callback=[TelegramErrorNotification()],
    )

    notify = PythonOperator(
        task_id="send_notifications",
        python_callable=send_notifications,
        on_failure_callback=[TelegramErrorNotification()],
    )

    wait >> notify